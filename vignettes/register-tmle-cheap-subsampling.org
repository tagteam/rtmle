* About

The R-package =rtmle= implements a class of targeted minimum loss
estimators for the analysis of longitudinal register data.
In this vignette, we detail how to use cheap subsampling with
the =rtmle= package to obtain robust inference.
In particular, the researcher may want to supplement their confidence intervals
with robust bootstrap confidence intervals if these appear
to be very narrow or wide. 
Cheap subsampling has been demonstrated to have
good coverage with few bootstrap data sets, see https://arxiv.org/abs/2501.10289.
Furthermore, we highlight two important features of using cheap subsampling with
=rtmle=:

1. Bootstrap confidence intervals based on the doubly robust LTMLE estimator, which, therefore, make the confidence intervals "doubly robust". 
2. Stability of the confidence intervals when the estimated propensity scores are close to zero. 

* Cheap subsampling confidence intervals

We consider register data in the following format.
See the document =register-tmle-intro.org=
for a more complete introduction to =rtmle=,
but we must first prepare and run =run_rtmle=
as we would normally do. 

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R  :results output verbatim  :exports both  :session *R* :cache yes
  library(rtmle)
  library(prodlim)
  library(riskRegression)
  library(data.table)

  tau <- 2
  set.seed(17)
  ld <- simulate_long_data(n = 91,number_visits = 20,beta = list(A_on_Y = -.2,A0_on_Y = -0.3,A0_on_A = 6),register_format = TRUE)
  x <- rtmle_init(intervals = tau,name_id = "id",name_outcome = "Y",name_competing = "Dead",name_censoring = "Censored",censored_label = "censored")
  x <- add_long_data(x,
                     outcome_data=ld$outcome_data,
                     censored_data=ld$censored_data,
                     competing_data=ld$competing_data,
                     timevar_data=ld$timevar_data)
  x <- add_baseline_data(x,data=ld$baseline_data)
  x <- long_to_wide(x,intervals = seq(0,2000,30.45*12))
  x <- protocol(x,name = "Always_A",intervention = data.frame("A" = factor("1",levels = c("0","1"))),verbose = FALSE)
  x <- protocol(x,name = "Never_A",intervention = data.frame("A" = factor("0",levels = c("0","1"))),verbose = FALSE)
  x <- prepare_data(x)
  x <- target(x,name = "Outcome_risk",estimator = "tmle",protocols = c("Always_A","Never_A"))
  x <- model_formula(x)
  # the overall analysis is stored as estimate$Main_analysis
  x <- run_rtmle(x,learner = "learn_glmnet",time_horizon = tau,verbose = FALSE)
#+END_SRC

To then obtain the cheap subsampling confidence intervals, we
run the =cheap_bootstrap= function. The important parameters are the following:
1. =B=: The number of bootstrap samples. 25
   is a sensible default, but if one wants
   to minimize Monte Carlo error
   (e.g., random noise from bootstrapping),
   one should set it higher.
2. =M=: Size of the bootstrap samples which by default
   is 63.2% of the number of rows of data.
   
Additional options can be found in the documentation for
the =cheap_bootstrap= function in =R=.
Later, we discuss how to determine these two important
parameters, but for now we demonstrate how to use the function:

#+ATTR_LATEX: :options otherkeywords={}, deletekeywords={}
#+BEGIN_SRC R  :results output verbatim  :exports both  :session *R* :cache 
  x <- cheap_bootstrap(x,B = 25,M = 0.632*NROW(x$prepared_data))
  summary(x)
#+END_SRC

#+begin_example
          Target Protocol Time_horizon Bootstrap_standard_error Bootstrap_lower Bootstrap_upper Target_parameter Estimator  Estimate
         <fctr>   <fctr>        <num>                    <num>           <num>           <num>           <fctr>    <fctr>     <num>
1: Outcome_risk Always_A            2               0.06410298      0.07905442       0.4250836             Risk      tmle 0.2520690
2: Outcome_risk  Never_A            2               0.08177774      0.16828033       0.6097183             Risk      tmle 0.3889993
3: Outcome_risk  Never_A            2               0.09979294      0.11005182       0.1638087  Risk_difference      tmle 0.1369303
4: Outcome_risk  Never_A            2               0.37972663      1.04571203       2.2774380       Risk_ratio      tmle 1.5432253
     P_value Standard_error      Lower     Upper Estimate (CI_95) Reference
       <num>          <num>      <num>     <num>           <char>    <char>
1: 1.0000000     0.07550702  0.1040780 0.4000601 25.2 [10.4;40.0]          
2: 1.0000000     0.08318565  0.2259584 0.5520402 38.9 [22.6;55.2]          
3: 0.2222327     0.11218159 -0.0829416 0.3568021 13.7 [-8.3;35.7]  Always_A
4: 0.2378117     0.36754267  0.7508902 3.1716278    1.5 [0.8;3.2]  Always_A
#+end_example

* When to use cheap subsampling

Because cheap subsampling makes the confidence intervals `doubly robust`,
one should, in principle, always use it since cheap subsampling
may provide inference when either the propensity score models
or outcome regressions are misspecified (but not both),
provided that nuisance parameter estimators converge sufficiently fast,
such as when one uses parametric models.
The influence curve-based confidence interval cannot provide
one with this feature.
Another feature is confidence intervals which are typically
less sensitive to small estimated propensity scores.
See for instance below:

#+BEGIN_SRC R  :results output verbatim drawer  :exports both  :session *R* :cache yes
  library(rtmle)
  library(prodlim)
  library(riskRegression)
  library(data.table)

  tau <- 2
  set.seed(450)
  ld <- simulate_long_data(n = 91,number_visits = 20,beta = list(age_on_A = -0.5, A_on_Y = -.2,A0_on_Y = -0.3,A0_on_A = 6),register_format = TRUE)
  x <- rtmle_init(intervals = tau,name_id = "id",name_outcome = "Y",name_competing = "Dead",name_censoring = "Censored",censored_label = "censored")
  x <- add_long_data(x,
                     outcome_data=ld$outcome_data,
                     censored_data=ld$censored_data,
                     competing_data=ld$competing_data,
                     timevar_data=ld$timevar_data)
  x <- add_baseline_data(x,data=ld$baseline_data)
  x <- long_to_wide(x,intervals = seq(0,2000,30.45*12))
  x <- protocol(x,name = "Always_A",intervention = data.frame("A" = factor("1",levels = c("0","1"))),verbose = FALSE)
  x <- protocol(x,name = "Never_A",intervention = data.frame("A" = factor("0",levels = c("0","1"))),verbose = FALSE)
  x <- prepare_data(x)
  x <- target(x,name = "Outcome_risk",estimator = "tmle",protocols = c("Always_A","Never_A"))
  x <- model_formula(x)
  # the overall analysis is stored as estimate$Main_analysis
  x<-run_rtmle(x,learner = "learn_glmnet",time_horizon = tau,verbose = FALSE)
  summary(x)
#+END_SRC

#+begin_example
          Target Protocol Target_parameter Time_horizon Estimator   Estimate   P_value Standard_error      Lower     Upper
         <fctr>   <fctr>           <fctr>        <num>    <fctr>      <num>     <num>          <num>      <num>     <num>
1: Outcome_risk Always_A             Risk            2      tmle 0.38913410 1.0000000     0.05612613  0.2791289 0.4991393
2: Outcome_risk  Never_A             Risk            2      tmle 0.40105554 1.0000000     0.08308268  0.2382165 0.5638946
3: Outcome_risk  Never_A  Risk_difference            2      tmle 0.01192144 0.9047137     0.09958691 -0.1832653 0.2071082
4: Outcome_risk  Never_A       Risk_ratio            2      tmle 1.03063582 0.9041935     0.25070195  0.6305323 1.6846245
   Estimate (CI_95) Reference
             <char>    <char>
1: 38.9 [27.9;49.9]          
2: 40.1 [23.8;56.4]          
3: 1.2 [-18.3;20.7]  Always_A
4:    1.0 [0.6;1.7]  Always_A
#+end_example

#+BEGIN_SRC R  :results output verbatim  :exports both  :session *R* :cache 
  # the bootstrap results are stored as estimate$Cheap_bootstrap
  x <- cheap_bootstrap(x,B = 25,M = 0.632*NROW(x$prepared_data))
  summary(x)
#+END_SRC

Running cheap bootstrap gives a narrower confidence interval in this case,
indicating perhaps that the estimated standard error was too high.

#+begin_example
         Target Protocol Time_horizon Bootstrap_standard_error Bootstrap_lower Bootstrap_upper Target_parameter Estimator   Estimate
         <fctr>   <fctr>        <num>                    <num>           <num>           <num>           <fctr>    <fctr>      <num>
1: Outcome_risk Always_A            2               0.08545803      0.15848199      0.61978621             Risk      tmle 0.38913410
2: Outcome_risk  Never_A            2               0.07731535      0.19238061      0.60973046             Risk      tmle 0.40105554
3: Outcome_risk  Never_A            2               0.12140565     -0.02786017      0.05170305  Risk_difference      tmle 0.01192144
4: Outcome_risk  Never_A            2               0.34017686      0.75415725      1.40847309       Risk_ratio      tmle 1.03063582
     P_value Standard_error      Lower     Upper Estimate (CI_95) Reference
       <num>          <num>      <num>     <num>           <char>    <char>
1: 1.0000000     0.05612613  0.2791289 0.4991393 38.9 [27.9;49.9]          
2: 1.0000000     0.08308268  0.2382165 0.5638946 40.1 [23.8;56.4]          
3: 0.9047137     0.09958691 -0.1832653 0.2071082 1.2 [-18.3;20.7]  Always_A
4: 0.9041935     0.25070195  0.6305323 1.6846245    1.0 [0.6;1.7]  Always_A
#+end_example

* How to use cheap subsampling

These choices should be considered only
if you have _time_ to do them as they require
more computation time.
Otherwise, one should stick with the default choices
of \(B\) and \(M\).

** Selection of \(B\)

Consider the example in the section `Cheap subsampling confidence intervals`.
Here, we can inspect the values of the cheap subsampling confidence intervals
using only \(b \leq B\) bootstrap samples in =x$estimate$Cheap_bootstrap=.
In the following code, we look at the cheap subsampling confidence intervals
only for the treated people:

#+BEGIN_SRC R  :results output verbatim  :exports both  :session *R* :cache 
library(ggplot2)
ggplot2::ggplot(
    data = x$estimate$Cheap_bootstrap[Target_parameter=="Risk" & Protocol=="Always_A"],
    ggplot2::aes(x = B, y = Main_Estimate)
  ) +
    ggplot2::geom_line() +
    ggplot2::geom_ribbon(
      alpha = 0.2,
      ggplot2::aes(
        ymin = Bootstrap_lower,
        ymax = Bootstrap_upper
      )
    ) +
    ggplot2::facet_wrap(~Time_horizon) + 
    ggplot2::theme_bw() +
    ggplot2::labs(x = "Number of bootstrap samples") +
    ggplot2::ylab("")
#+END_SRC

To find out whether the values have stabilized, we add
another 25 bootstrap samples as follows to get
a total of 50 bootstrap samples.
It looks fairly stable!

#+BEGIN_SRC R  :results output verbatim  :exports both  :session *R* :cache
x <- cheap_bootstrap(x,add =TRUE,B = 25,M = 0.632*NROW(x$prepared_data))
ggplot2::ggplot(
    data = x$estimate$Cheap_bootstrap[Target_parameter=="Risk" & Protocol=="Always_A"],
    ggplot2::aes(x = B, y = Main_Estimate)
  ) +
    ggplot2::geom_line() +
    ggplot2::geom_ribbon(
      alpha = 0.2,
      ggplot2::aes(
        ymin = Bootstrap_lower,
        ymax = Bootstrap_upper
      )
    ) +
    ggplot2::facet_wrap(~Time_horizon) + 
    ggplot2::theme_bw() +
    ggplot2::labs(x = "Number of bootstrap samples") +
    ggplot2::ylab("")
#+END_SCR

** Selection of \(M\)

This question is more difficult to answer in practice.
A sensible default is to use \(M = 0.632 n\),
where \(n\) is the number of rows in the data.
One should make sure that the confidence intervals
do not change too much when changing \(M\),
for instance along a grid of values, such as
\(M \in \{0.5 n, 0.632, 0.75 n, 0.8 n\}\).
If they do, one should consider increasing \(B\)
which should reduce the Monte Carlo error
and help stabilize the confidence intervals.

#+TITLE: Using rtmle with the cheap subsampling confidence interval
#+Author: Johan Sebastian Ohlendorff
#+Date: 
#+EMAIL: johan.ohlendorff@sund.ku.dk
#+LaTeX_CLASS: org-article
#+OPTIONS: H:3 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS: TeX:t LaTeX:t skip:nil d:t todo:t pri:nil tags:not-in-toc author:nil
#+LaTeX_HEADER:\usepackage{authblk}
#+LaTeX_HEADER:\usepackage{natbib}
#+LaTeX_HEADER:\author{Johan Sebastian Ohlendorff}
#+LaTeX_HEADER:\affil{Department of Biostatistics, University of Copenhagen}
#+set: superman-org-export-target: html

